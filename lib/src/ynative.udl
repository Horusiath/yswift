namespace ynative {};

[Error]
enum CodingError {
  "EncodingError",
  "DecodingError",
};

interface Transaction {
  [Throws=CodingError]
  void transaction_apply_update(sequence<u8> update);
  [Throws=CodingError]
  sequence<u8> transaction_encode_state_as_update_from_sv(sequence<u8> state_vector);
  sequence<u8> transaction_encode_state_as_update();
  sequence<u8> transaction_encode_update();
  sequence<u8> transaction_state_vector();
  Text? transaction_get_text(string name);
  void free();
};

interface Text {
  void append([ByRef] Transaction tx, string text);
  void insert([ByRef] Transaction tx, u32 index, string chunk);
  string get_string([ByRef] Transaction tx);
  void remove_range([ByRef] Transaction tx, u32 start, u32 length);
  u32 length([ByRef] Transaction tx);
};

interface YArray {
  [Throws=CodingError]
  string get([ByRef] Transaction tx, u32 index);
  void insert([ByRef] Transaction tx, u32 index, string value);
  void insert_range([ByRef] Transaction tx, u32 index, sequence<string> values);
  u32 length([ByRef] Transaction tx);
  void push_back([ByRef] Transaction tx, string value);
  void push_front([ByRef] Transaction tx, string value);
  void remove([ByRef] Transaction tx, u32 index);
  void remove_range([ByRef] Transaction tx, u32 index, u32 len);
  sequence<string> to_a([ByRef] Transaction tx);
};

interface Doc {
  constructor();
  [Throws=CodingError]
  sequence<u8> encode_diff_v1([ByRef] Transaction tx, sequence<u8> state_vector);
  Text get_text(string name);
  YArray get_array(string name);
  Transaction transact();
};
