// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// Check for compatibility between `uniffi` and `uniffi_bindgen` versions.
// Note that we have an error message on the same line as the assertion.
// This is important, because if the assertion fails, the compiler only
// seems to show that single line as context for the user.
uniffi::assert_compatible_version!("0.22.0"); // Please check that you depend on version 0.22.0 of the `uniffi` crate.

// Everybody gets basic buffer support, since it's needed for passing complex types over the FFI.
//
// See `uniffi/src/ffi/rustbuffer.rs` for documentation on these functions

#[allow(clippy::missing_safety_doc)]
#[no_mangle]
pub extern "C" fn ffi_yswift_a312_rustbuffer_alloc(
    size: i32,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    uniffi::ffi::uniffi_rustbuffer_alloc(size, call_status)
}

#[allow(clippy::missing_safety_doc)]
#[no_mangle]
pub unsafe extern "C" fn ffi_yswift_a312_rustbuffer_from_bytes(
    bytes: uniffi::ForeignBytes,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    uniffi::ffi::uniffi_rustbuffer_from_bytes(bytes, call_status)
}

#[allow(clippy::missing_safety_doc)]
#[no_mangle]
pub unsafe extern "C" fn ffi_yswift_a312_rustbuffer_free(
    buf: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) {
    uniffi::ffi::uniffi_rustbuffer_free(buf, call_status)
}

#[allow(clippy::missing_safety_doc)]
#[no_mangle]
pub unsafe extern "C" fn ffi_yswift_a312_rustbuffer_reserve(
    buf: uniffi::RustBuffer,
    additional: i32,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    uniffi::ffi::uniffi_rustbuffer_reserve(buf, additional, call_status)
}

// Error definitions, corresponding to `error` in the UDL.

// Enum defitions, corresponding to `enum` in UDL.

// Record definitions, implemented as method-less structs, corresponding to `dictionary` objects.

// Top level functions, corresponding to UDL `namespace` functions.// Object definitions, corresponding to UDL `interface` definitions.

// For each Object definition, we assume the caller has provided an appropriately-shaped `struct T`
// with an `impl` for each method on the object. We create an `Arc<T>` for "safely" handing out
// references to these structs to foreign language code, and we provide a `pub extern "C"` function
// corresponding to each method.
//
// (Note that "safely" is in "scare quotes" - that's because we use functions on an `Arc` that
// that are inherently unsafe, but the code we generate is safe in practice.)
//
// If the caller's implementation of the struct does not match with the methods or types specified
// in the UDL, then the rust compiler will complain with a (hopefully at least somewhat helpful!)
// error message when processing this generated code.

// All Object structs must be `Sync + Send`. The generated scaffolding will fail to compile
// if they are not, but unfortunately it fails with an unactionably obscure error message.
// By asserting the requirement explicitly, we help Rust produce a more scrutable error message
// and thus help the user debug why the requirement isn't being met.
uniffi::deps::static_assertions::assert_impl_all!(r#Transaction: Sync, Send);

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn ffi_yswift_a312_Transaction_object_free(
    ptr: *const std::os::raw::c_void,
    call_status: &mut uniffi::RustCallStatus,
) {
    uniffi::call_with_output(call_status, || {
        assert!(!ptr.is_null());
        drop(unsafe { std::sync::Arc::from_raw(ptr as *const r#Transaction) })
    })
}
#[doc(hidden)]
#[no_mangle]
#[allow(clippy::let_unit_value)] // Sometimes we generate code that binds `_retval` to `()`.
pub extern "C" fn r#yswift_a312_Transaction_free(
    r#ptr: *const std::os::raw::c_void,
    call_status: &mut uniffi::RustCallStatus,
) {
    uniffi::deps::log::debug!("yswift_a312_Transaction_free");
    // If the method does not have the same signature as declared in the UDL, then
    // this attempt to call it will fail with a (somewhat) helpful compiler error.

    uniffi::call_with_output(call_status, || {
        r#Transaction::r#free(
            match <std::sync::Arc<r#Transaction> as uniffi::FfiConverter>::try_lift(r#ptr) {
                Ok(ref val) => val,
                Err(err) => panic!("Failed to convert arg '{}': {}", "ptr", err),
            },
        )
    })
}

// For each Object definition, we assume the caller has provided an appropriately-shaped `struct T`
// with an `impl` for each method on the object. We create an `Arc<T>` for "safely" handing out
// references to these structs to foreign language code, and we provide a `pub extern "C"` function
// corresponding to each method.
//
// (Note that "safely" is in "scare quotes" - that's because we use functions on an `Arc` that
// that are inherently unsafe, but the code we generate is safe in practice.)
//
// If the caller's implementation of the struct does not match with the methods or types specified
// in the UDL, then the rust compiler will complain with a (hopefully at least somewhat helpful!)
// error message when processing this generated code.

// All Object structs must be `Sync + Send`. The generated scaffolding will fail to compile
// if they are not, but unfortunately it fails with an unactionably obscure error message.
// By asserting the requirement explicitly, we help Rust produce a more scrutable error message
// and thus help the user debug why the requirement isn't being met.
uniffi::deps::static_assertions::assert_impl_all!(r#Text: Sync, Send);

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn ffi_yswift_a312_Text_object_free(
    ptr: *const std::os::raw::c_void,
    call_status: &mut uniffi::RustCallStatus,
) {
    uniffi::call_with_output(call_status, || {
        assert!(!ptr.is_null());
        drop(unsafe { std::sync::Arc::from_raw(ptr as *const r#Text) })
    })
}
#[doc(hidden)]
#[no_mangle]
#[allow(clippy::let_unit_value)] // Sometimes we generate code that binds `_retval` to `()`.
pub extern "C" fn r#yswift_a312_Text_append(
    r#ptr: *const std::os::raw::c_void,
    r#tx: *const std::os::raw::c_void,
    r#text: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) {
    uniffi::deps::log::debug!("yswift_a312_Text_append");
    // If the method does not have the same signature as declared in the UDL, then
    // this attempt to call it will fail with a (somewhat) helpful compiler error.

    uniffi::call_with_output(call_status, || {
        r#Text::r#append(
            match <std::sync::Arc<r#Text> as uniffi::FfiConverter>::try_lift(r#ptr) {
                Ok(ref val) => val,
                Err(err) => panic!("Failed to convert arg '{}': {}", "ptr", err),
            },
            match <std::sync::Arc<r#Transaction> as uniffi::FfiConverter>::try_lift(r#tx) {
                Ok(ref val) => val,
                Err(err) => panic!("Failed to convert arg '{}': {}", "tx", err),
            },
            match <String as uniffi::FfiConverter>::try_lift(r#text) {
                Ok(val) => val,
                Err(err) => panic!("Failed to convert arg '{}': {}", "text", err),
            },
        )
    })
}

#[doc(hidden)]
#[no_mangle]
#[allow(clippy::let_unit_value)] // Sometimes we generate code that binds `_retval` to `()`.
pub extern "C" fn r#yswift_a312_Text_get_string(
    r#ptr: *const std::os::raw::c_void,
    r#tx: *const std::os::raw::c_void,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    uniffi::deps::log::debug!("yswift_a312_Text_get_string");
    // If the method does not have the same signature as declared in the UDL, then
    // this attempt to call it will fail with a (somewhat) helpful compiler error.

    uniffi::call_with_output(call_status, || {
        let retval = r#Text::r#get_string(
            match <std::sync::Arc<r#Text> as uniffi::FfiConverter>::try_lift(r#ptr) {
                Ok(ref val) => val,
                Err(err) => panic!("Failed to convert arg '{}': {}", "ptr", err),
            },
            match <std::sync::Arc<r#Transaction> as uniffi::FfiConverter>::try_lift(r#tx) {
                Ok(ref val) => val,
                Err(err) => panic!("Failed to convert arg '{}': {}", "tx", err),
            },
        );
        <String as uniffi::FfiConverter>::lower(retval)
    })
}

// For each Object definition, we assume the caller has provided an appropriately-shaped `struct T`
// with an `impl` for each method on the object. We create an `Arc<T>` for "safely" handing out
// references to these structs to foreign language code, and we provide a `pub extern "C"` function
// corresponding to each method.
//
// (Note that "safely" is in "scare quotes" - that's because we use functions on an `Arc` that
// that are inherently unsafe, but the code we generate is safe in practice.)
//
// If the caller's implementation of the struct does not match with the methods or types specified
// in the UDL, then the rust compiler will complain with a (hopefully at least somewhat helpful!)
// error message when processing this generated code.

// All Object structs must be `Sync + Send`. The generated scaffolding will fail to compile
// if they are not, but unfortunately it fails with an unactionably obscure error message.
// By asserting the requirement explicitly, we help Rust produce a more scrutable error message
// and thus help the user debug why the requirement isn't being met.
uniffi::deps::static_assertions::assert_impl_all!(r#Doc: Sync, Send);

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn ffi_yswift_a312_Doc_object_free(
    ptr: *const std::os::raw::c_void,
    call_status: &mut uniffi::RustCallStatus,
) {
    uniffi::call_with_output(call_status, || {
        assert!(!ptr.is_null());
        drop(unsafe { std::sync::Arc::from_raw(ptr as *const r#Doc) })
    })
}
#[doc(hidden)]
#[no_mangle]
pub extern "C" fn r#yswift_a312_Doc_new(
    call_status: &mut uniffi::RustCallStatus,
) -> *const std::os::raw::c_void /* *const Doc */ {
    uniffi::deps::log::debug!("yswift_a312_Doc_new");

    // If the constructor does not have the same signature as declared in the UDL, then
    // this attempt to call it will fail with a (somewhat) helpful compiler error.

    uniffi::call_with_output(call_status, || {
        let _new = r#Doc::r#new();
        let _arc = std::sync::Arc::new(_new);
        <std::sync::Arc<r#Doc> as uniffi::FfiConverter>::lower(_arc)
    })
}
#[doc(hidden)]
#[no_mangle]
#[allow(clippy::let_unit_value)] // Sometimes we generate code that binds `_retval` to `()`.
pub extern "C" fn r#yswift_a312_Doc_get_text(
    r#ptr: *const std::os::raw::c_void,
    r#name: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> *const std::os::raw::c_void {
    uniffi::deps::log::debug!("yswift_a312_Doc_get_text");
    // If the method does not have the same signature as declared in the UDL, then
    // this attempt to call it will fail with a (somewhat) helpful compiler error.

    uniffi::call_with_output(call_status, || {
        let retval = r#Doc::r#get_text(
            match <std::sync::Arc<r#Doc> as uniffi::FfiConverter>::try_lift(r#ptr) {
                Ok(ref val) => val,
                Err(err) => panic!("Failed to convert arg '{}': {}", "ptr", err),
            },
            match <String as uniffi::FfiConverter>::try_lift(r#name) {
                Ok(val) => val,
                Err(err) => panic!("Failed to convert arg '{}': {}", "name", err),
            },
        );
        <std::sync::Arc<r#Text> as uniffi::FfiConverter>::lower(retval)
    })
}

#[doc(hidden)]
#[no_mangle]
#[allow(clippy::let_unit_value)] // Sometimes we generate code that binds `_retval` to `()`.
pub extern "C" fn r#yswift_a312_Doc_transact(
    r#ptr: *const std::os::raw::c_void,
    call_status: &mut uniffi::RustCallStatus,
) -> *const std::os::raw::c_void {
    uniffi::deps::log::debug!("yswift_a312_Doc_transact");
    // If the method does not have the same signature as declared in the UDL, then
    // this attempt to call it will fail with a (somewhat) helpful compiler error.

    uniffi::call_with_output(call_status, || {
        let retval = r#Doc::r#transact(
            match <std::sync::Arc<r#Doc> as uniffi::FfiConverter>::try_lift(r#ptr) {
                Ok(ref val) => val,
                Err(err) => panic!("Failed to convert arg '{}': {}", "ptr", err),
            },
        );
        <std::sync::Arc<r#Transaction> as uniffi::FfiConverter>::lower(retval)
    })
}

// Callback Interface definitions, corresponding to UDL `callback interface` definitions.

// External and Wrapped types
// Support for external types.

// Types with an external `FfiConverter`...

// For custom scaffolding types we need to generate an FfiConverterType based on the
// UniffiCustomTypeConverter implementation that the library supplies

// The `reexport_uniffi_scaffolding` macro
// Code to re-export the UniFFI scaffolding functions.
//
// Rust won't always re-export the functions from dependencies
// ([rust-lang#50007](https://github.com/rust-lang/rust/issues/50007))
//
// A workaround for this is to have the dependent crate reference a function from its dependency in
// an extern "C" function. This is clearly hacky and brittle, but at least we have some unittests
// that check if this works (fixtures/reexport-scaffolding-macro).
//
// The main way we use this macro is for that contain multiple UniFFI components (libxul,
// megazord).  The combined library has a cargo dependency for each component and calls
// uniffi_reexport_scaffolding!() for each one.

#[doc(hidden)]
pub fn uniffi_reexport_hack() {}

#[macro_export]
macro_rules! uniffi_reexport_scaffolding {
    () => {
        #[doc(hidden)]
        #[no_mangle]
        pub extern "C" fn yswift_uniffi_reexport_hack() {
            $crate::uniffi_reexport_hack()
        }
    };
}
